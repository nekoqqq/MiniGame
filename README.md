## é¡¹ç›®æ¦‚è¿°

å‚ç…§ã€æ¸¸æˆå¼€å‘ï¼šä¸–å˜‰æ–°äººåŸ¹è®­æ•™æã€‘ä¸€ä¹¦ï¼ŒåŸºäºC++å¼€å‘çš„æ§åˆ¶å°ã€2Då’Œ3Dæ¸¸æˆæ¼”ç¤ºé¡¹ç›®ï¼Œå®ç°äº†å®Œæ•´çš„ç»˜å›¾ç³»ç»Ÿã€ç¢°æ’ç³»ç»Ÿã€å…‰ç…§å’Œæ¸¸æˆç©æ³•ç³»ç»Ÿçš„æ¸¸æˆdemoã€‚

https://github.com/user-attachments/assets/55b77249-ff9f-400d-aef0-f191623fa360

### **ç‰¹ç‚¹**ï¼š

- åŸç”ŸC++å®ç°ï¼Œå°½å¯èƒ½å‡å°‘ç¬¬ä¸‰æ–¹å¼•æ“çš„ä¾èµ–
- ä»XMLæ–‡ä»¶ä¸­è¯»å–æ¨¡å‹é…ç½®
- åŠ¨ç”»ç³»ç»Ÿæ•°æ®åŒ–
- Lambertå…‰ç…§ç³»ç»Ÿ
- é«˜æ•ˆçš„çŸ©é˜µå˜æ¢å’Œæ•°å­¦è¿ç®—åº“
- æ¨¡å—åŒ–æ¶æ„è®¾è®¡ï¼Œæ˜“äºæ‰©å±•æ–°æ¸¸æˆçŠ¶æ€

[![GitHub stars](https://img.shields.io/github/stars/yourusername/game-engine-demo?style=social)](https://github.com/nekoqqq/MiniGame)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

## ç³»ç»Ÿç®€ä»‹

### ğŸš€ æ ¸å¿ƒå­ç³»ç»Ÿ

- **è‡ªå®šä¹‰3Dæ¸²æŸ“ç®¡çº¿**ï¼š
  - æ˜“ç”¨çš„ç»˜åˆ¶ç³»ç»Ÿ
  - æ”¯æŒçº¹ç†è´´å›¾å’ŒUVæ˜ å°„
  - æ³•çº¿è´´å›¾å’ŒLambertå…‰ç…§ç³»ç»Ÿ
- **ç‰©ç†å¼•æ“**ï¼š
  - ä¸‰ç»´ã€å››ç»´é½æ¬¡çŸ©é˜µçº¿æ€§å˜æ¢è®¡ç®—åº“
  - ç¢°æ’æ£€æµ‹ç³»ç»Ÿï¼ˆä¸‰è§’å½¢ã€çƒä½“ã€ç«‹æ–¹ä½“ï¼‰
  - é‡åŠ›ç³»ç»Ÿ
  - çŸ©å½¢ã€ä¸‰è§’å½¢ã€çƒé¢ç­‰å‡ ä½•ä½“ç¢°æ’æ£€æµ‹
- **èµ„æºç®¡ç†ç³»ç»Ÿ**ï¼š
  - XMLæ–‡ä»¶è¯»å–æ¨¡å—
  - é¡¶ç‚¹/ç´¢å¼•ç¼“å­˜/æ¨¡å‹/çº¹ç†èµ„æºæ•°æ®åŒ–åŠ è½½
- **åŠ¨ç”»ç³»ç»Ÿï¼š**
  - XMLæ–‡ä»¶é…ç½®åŒ–è¯»å–
  - æ”¯æŒç‰©ä½“å˜æ¢å¦‚ç¼©æ”¾ã€å¹³ç§»ã€æ—‹è½¬ç­‰

### ğŸ® æ¸¸æˆåŠŸèƒ½å®ç°

- **è§’è‰²æ§åˆ¶ç³»ç»Ÿ**ï¼š
  - è§’è‰²ç§»åŠ¨å’Œè·³è·ƒç‰©ç†
  - è§†è§’æ—‹è½¬æ§åˆ¶
  - å¯¼å¼¹å‘å°„å’Œè·Ÿè¸ªç³»ç»Ÿ
  - ç›®æ ‡è‡ªåŠ¨é”å®šåˆ¤å®šæœºåˆ¶
- **AIè¡Œä¸ºç³»ç»Ÿ**ï¼š
  - æ•Œäººéšæœºç§»åŠ¨å’Œæ”»å‡»
- **æ¸¸æˆæœºåˆ¶**ï¼š
  - ç”Ÿå‘½å€¼(HP)ç³»ç»Ÿ
  - å€’è®¡æ—¶å’Œæ¸¸æˆçŠ¶æ€ç®¡ç†
  - å°åœ°å›¾å®ç°
- **åŠ¨ç”»ç³»ç»Ÿ**ï¼š
  - çˆ†ç‚¸å†²å‡»æ³¢ï¼ˆäºŒç»´æ¸¸æˆï¼‰
  - åŠ¨ç”»æ’å€¼ï¼ˆçº¿æ€§ã€äºŒæ¬¡ã€ä¸‰æ¬¡ï¼‰

### âš™ï¸ æ€§èƒ½ä¼˜åŒ–

- **ç¢°æ’æ£€æµ‹**
  - äººç‰©å’Œåœ°é¢ç¢°æ’é‡‡ç”¨ç®€åŒ–çš„çº¿æ®µå’Œä¸‰è§’å½¢ä½ç½®åˆ¤æ–­
  - ç‰©ä½“ä¹‹é—´é‡‡ç”¨çƒå‹åŒ…å›´ç›’åˆ¤æ–­

- **æ¸²æŸ“ä¼˜åŒ–**ï¼š
  - å…‰ç…§æ¨¡å‹æ³•çº¿è®¡ç®—æœ¬åœ°åŒ–å‡å°‘çŸ©é˜µè¿ç®—
  - z-bufferæ˜¯å¦å¼€å¯æ·±åº¦æµ‹è¯•åŒºåˆ†é€æ˜å’Œä¸é€æ˜çš„ç‰©ä½“ç»˜åˆ¶
  - é‡‡ç”¨é«˜æ•ˆçš„æ•°æ®ç»“æ„Hashè¡¨ï¼Œä»æ¨¡å‹æ–‡ä»¶ä¸­è¯»å–ç»˜å›¾ç±»ï¼Œå¤ç”¨é¡¶ç‚¹æ•°æ®
- **å†…å­˜ä¼˜åŒ–**ï¼š
  - åŠ¨æ€å†…å­˜ç®¡ç†
  - STLæ•°æ®ç»“æ„æ”¯æŒç³»ç»Ÿ

## ç³»ç»Ÿæ¶æ„

```mermaid
graph TD
    A[æ¸¸æˆå¼•æ“æ ¸å¿ƒ] --> B[æ¸²æŸ“ç³»ç»Ÿ]
    A --> C[ç‰©ç†ç³»ç»Ÿ]
    A --> D[èµ„æºç®¡ç†ç³»ç»Ÿ]
    A --> E[è¾“å…¥ç³»ç»Ÿ]
    
    B --> F[3Dæ¨¡å‹æ¸²æŸ“]
    B --> G[çº¹ç†è´´å›¾]
    B --> H[å…‰ç…§è®¡ç®—]
    
    C --> J[ç¢°æ’æ£€æµ‹]
    C --> K[è¿åŠ¨æ¨¡æ‹Ÿ]
    C --> L[ç¢°æ’å“åº”]
    
    D --> M[æ¨¡å‹åŠ è½½]
    D --> N[åŠ¨ç”»ç®¡ç†]
    D --> O[é…ç½®æ–‡ä»¶è§£æ]
    
    E --> P[é”®ç›˜è¾“å…¥]
    E --> Q[é¼ æ ‡æ§åˆ¶]
    
    A --> R[æ¸¸æˆé€»è¾‘]
    R --> S[è§’è‰²æ§åˆ¶]
    R --> T[AIç³»ç»Ÿ]
    R --> U[æ¸¸æˆçŠ¶æ€ç®¡ç†]
```

## å…³é”®å®ç°ç»†èŠ‚

### ç»˜åˆ¶ç³»ç»Ÿ

```cpp
class Model{
    virtual void draw(const Matrix44 &pv, const Light* light)=0 {
		painter_->draw(pv, getModelTransform(), light);
	}
}	

class Painter{
    	void draw(const Matrix44& pv, const Matrix44& wm, const Light* light)const {
		vector<Vector3> res(vb_->size());
		vector<Vector3> world_coords(vb_->size());
		for (int i = 0; i < vb_->size(); i++) {
			world_coords[i] = wm.vecMul(vb_->vertex(i));
		}
		for (int i = 0; i < vb_->size(); i++) {
			res[i] = pv.vecMul(world_coords[i]);
		}
		Framework f = Framework::instance();
		if (blend_mode_ == Framework::BLEND_OPAQUE) {
			f.enableDepthWrite(true);
		}
		else {
			f.enableDepthWrite(false);
		}
		if (texture_)
			texture_->set();
		else
			f.setTexture(nullptr); // TODOè¿™é‡Œçš„å°è£…ä¸å¤ªä¼˜é›…
		f.enableDepthTest(isZTest_);
		f.setBlendMode(blend_mode_);
		vector<unsigned> colors(vb_->size());
		for (int i = 0; i < vb_->size(); i++) {
			Matrix44 wm_tmp = wm.dropRotation(); // è¿™é‡Œéœ€è¦å‰”é™¤æ‰æ³•çº¿å‘é‡å¹³ç§»çš„åˆ†é‡
			Vector3 transformed_norm = wm.vecMul(norms_[i]).normalize(); 
			colors[i] = light->calculate(transformed_norm,vb_->color(i));
		}
		for (int i = 0; i < ib_->size(); i++) {
			int i0 = (*ib_)[i][0], i1 = (*ib_)[i][1], i2 = (*ib_)[i][2];
			unsigned c0 = vb_->color(i0);
			unsigned c1 = vb_->color(i1);
			unsigned c2 = vb_->color(i2);
			Vector3 norm = (world_coords[i1] - world_coords[i0]).cross(world_coords[i2] - world_coords[i0]).normalize(); // å…‰ç…§çš„è®¡ç®—ä½¿ç”¨ä¸–ç•Œåæ ‡ 
			
			// æ³¨æ„è¿™é‡Œä¸èƒ½ç”¨æå‰ç®—å¥½çš„æ³•å‘é‡ï¼Œå› ä¸ºwmçŸ©é˜µæœ‰æ—‹è½¬æˆåˆ†
			c0=light->calculate(norm, c0);
			c1 = light->calculate(norm, c1);
			c2 = light->calculate(norm, c2);
			f.drawTriangle3DH(res[i0], res[i1], res[i2], vb_->uv(i0).data(), vb_->uv(i1).data(), vb_->uv(i2).data(), c0,c1,c2);
		}
	}
}

```

### å…‰ç…§æ¨¡å‹

```cpp
struct Light
{
	Light(const Vector3& light_dir, const Vector3& light_color,const Vector3&ambient)
	{
		this->light_dir = light_dir;
		this->light_color = light_color;
		this->ambient = ambient;
	}
	void updateLight(const Vector3&new_dir)
	{
		light_dir = new_dir;
	}
	unsigned calculate(const Vector3& norm, unsigned diffuse_color)const
	{
		Vector3 diffuse = { (diffuse_color >> 16 & 0xff)/255.0, ((diffuse_color >> 8) &0xff)/255.0, (diffuse_color & 0xff)/255.0 };
		// ä¸‰è§’å½¢è¡¨é¢æ³•å‘é‡, n
		// diffuse ç‰©ä½“æœ¬èº«çš„æ€§è´¨,æ¼«åå°„ç‡,åå°„RGBä¸‰ç§é¢œè‰²çš„å¼ºåº¦,0åˆ°1,1æœ€å¤§, R
		double c = light_dir.dot(norm)/light_dir.norm();
		c = max(0.0, c);
		Vector3 color = light_color.elementMul(diffuse) * c + ambient; // RGB
		unsigned r = max(0.0, min(1.0, color.x))*255.0;
		unsigned g = max(0.0, min(1.0, color.y))*255.0;
		unsigned b = max(0.0, min(1.0, color.z))*255.0;
		return (0xff << 24) | (r << 16) | (g << 8) | b;
	}
	// åŸºç¡€å…‰ç…§æ¨¡å‹, I = I0*R*(n.l)/ d^2 +a ï¼Œç”±äºè·ç¦»è¾ƒè¿œï¼Œå¯ä»¥å°†åˆ†æ¯å¿½ç•¥
	// è¿™é‡Œä¸ºäº†å¤ç”¨Vector3è¿™ä¸ªç±»åº“ï¼Œæ‰€ä»¥è®¾ç½®äº†å½’ä¸€åŒ–çš„RGBå€¼
	Vector3 light_dir; // å…‰çº¿çš„æ–¹å‘å‘é‡ï¼Œç”±ç‰©ä½“æŒ‡å‘å…‰æº, l
	Vector3 light_color; // å…‰æºçš„æ€§è´¨,RGBä¸‰ç§é¢œè‰²çš„å¼ºåº¦,0åˆ°1,1æœ€å¼ºï¼Œè¡¨ç¤ºå…‰çš„å¼ºåº¦, I0
	Vector3 ambient; // ç¯å¢ƒå…‰ï¼Œå„ä¸ªé¢œè‰²çš„åˆ†é‡å¼ºåº¦å…¶å®å°±æ˜¯ä¸€ä¸ªunsigned, a
};
```

## åŠ¨ç”»ç³»ç»Ÿ

- å®ç°åŸºäºå…³é”®å¸§è¿›è¡Œæ’å€¼çš„åŠ¨ç”»ç³»ç»Ÿ
- æ”¯æŒä¸‰ç§æ’å€¼ç®—æ³•ï¼šçº¿æ€§ã€äºŒæ¬¡å’Œä¸‰æ¬¡
- ä»é…ç½®æ–‡ä»¶åŠ è½½åŠ¨ç”»æ•°æ®
- å˜æ¢æ ‘å’ŒåŠ¨ç”»æ ‘å…³è”ï¼Œç”¨åŠ¨ç”»æ ‘ç®¡ç†ä¸åŒçŠ¶æ€é—´çš„è¿‡æ¸¡

```cpp
// åŠ¨ç”»æ’å€¼ç¤ºä¾‹
class Curve{
double get(double time) const {
	time = fmod(time, datas_.back()->time); // ç¡®ä¿æ—¶é—´åœ¨å¾ªç¯èŒƒå›´å†…
	switch (interpolation_type_)
	{
	case Curve::NONE:
		{
			// æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤§äºç­‰äºtimeçš„ç‚¹
			for (int i = 0; i < datas_.size(); i++) {
				if (datas_[i]->time >= time) {
					return datas_[i]->value;
				}
			}
			return datas_.back()->value; // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œè¿”å›æœ€åä¸€ä¸ªç‚¹çš„å€¼
		}
		break;
	case Curve::LINEAR:
		// çº¿æ€§æ’å€¼
		for (int i = 0; i < datas_.size() - 1; i++) {
			if (datas_[i]->time <= time && datas_[i + 1]->time >= time) {
				double t = (time - datas_[i]->time) / (datas_[i + 1]->time - datas_[i]->time);
				return datas_[i]->value + t * (datas_[i + 1]->value - datas_[i]->value);
			}
		}
		break;
	case Curve::CUBIC:
	{
		int beg = 0;
		int end = 0;
		for ( end = 0; end < datas_.size(); end++) {
			if (datas_[end]->time > time)
				break;
			beg = end;
		}
		double t0 = datas_[beg]->time;
		double t1 = datas_[end]->time;
		double p0 = datas_[beg]->value;
		double p1 = datas_[end]->value;
		double v0 = datas_[beg]->right_slope_;
		double v1 = datas_[end]->left_slope_;
		time = (time - t0) / (t1 - t0); // å½’ä¸€åŒ–æ—¶é—´
		double a = 2.0 * (p0 - p1) + v0 + v1;
		double b = 3.0 * (p1 - p0) - (2.0 * v0) - v1;
		double r = a;
		r *= time;
		r += b;
		r *= time;
		r += v0;
		r *= time;
		r += p0;
		return r;
	}
		break;
	case Curve::HERMITE:
		break;
	default:
		break;
	}
}
}
```

## å¯¼å¼¹è·Ÿè¸ªç³»ç»Ÿ

- å®ç°ä¸€å®šç¨‹åº¦è‡ªåŠ¨è·Ÿè¸ªç›®æ ‡
- ç®€åŒ–çš„ç¢°æ’æ£€æµ‹

```cpp
class Missle{
    void updateVelocity(const Vector3&dir, double rotation_speed)
{
	// æ—§çš„ä»£ç 
		 //velocity_ = (velocity_ * 0.95 + dir * 0.05).normalize() ;
		 //rotateZ(MISSLE_ROTATION_SPEED); // æ—§çš„ä»£ç ï¼Œç»•ç€è‡ªèº«çš„é€Ÿåº¦æ–¹å‘æ—‹è½¬

		// å¯ä»¥æŒ‰ç…§å…ˆxå†yçš„é¡ºåºï¼Œä¹Ÿå¯ä»¥æŒ‰ç…§å…ˆyå†xçš„é¡ºåºï¼Œä½†æ˜¯ä¸¤æ¬¡çš„è§’åº¦æ˜¯ä¸ä¸€æ ·çš„
	double y_rotation = atan2(dir.x, dir.z) * 180 / PI;
	double x_rotation = atan2(dir.y, sqrt((dir.x * dir.x + dir.z * dir.z))) * 180 / PI;
	double offset = 1.0;
	if (fabs(rotation.y - y_rotation) < offset) {
		rotation.y = y_rotation;
	}
	else if (rotation.y - y_rotation > 0.0) {
		rotation.y -= offset;
	}
	else {
		rotation.y += offset;
	}

	if (fabs(rotation.x - x_rotation) < offset) {
		rotation.x = x_rotation;
	}
	else if (rotation.x - x_rotation > 0.0) {
		rotation.x -= offset;
	}
	else {
		rotation.x += offset;
	}
	rotation.z += rotation_speed;
	setRotationY(rotation.y);
	rotateX(-rotation.x);
	rotateZ(rotation.z);
	velocity_ = getModelRotation().vecMul({ 0,0,0.5 });
}

```

## ç‰©ç†ç¢°æ’æ£€æµ‹

- æ”¯æŒå¤šç§ç¢°æ’ä½“ç±»å‹ï¼ˆçƒä½“ã€AABBï¼‰
- ç¢°æ’å“åº”å’Œç‰©ä½“åå¼¹

```cpp
class Mecha{
    void collisionTest()
{
	// å­˜åœ¨ä¸€ä¸ªæ–¹å‘ï¼Œä½¿å¾—å’Œå…¶ä»–æ‰€æœ‰ç‰©ä½“éƒ½ä¸ç›¸æ’ï¼Œæ‰å¯ä»¥ç§»åŠ¨
	// åä¹‹ï¼Œå­˜åœ¨ä¸€ä¸ªç‰©ä½“ï¼Œæ‰€æœ‰æ–¹å‘éƒ½å’Œä»–ç›¸æ’ï¼Œåˆ™ä¸å¯ä»¥ç§»åŠ¨
	// TODO ç›®å‰çš„å¤„ç†å­˜åœ¨æŠ–åŠ¨ç°è±¡ï¼Œç›¸å½“äºè¯´æ¯å¸§ç‰©ä½“çš„ç§»åŠ¨æ–¹å‘éƒ½ä¼šå‘ç”Ÿæ”¹å˜ï¼Œæ¯”å¦‚åœ¨çˆ¬å¾ˆæŠ–çš„å¡çš„æ—¶å€™ï¼Œä¸€ä¼šå„¿å‘å‰ï¼Œä¸€ä¼šå„¿å‘å
	const Vector3 old_pos = getPos();
	if (getCollsionModel()->getType() == CollisionModel::Type::CUBOID) {
		vector<Vector3> possible_move_vectors = {
			velocity_,
			{0.0,velocity_.y,velocity_.z},
			{velocity_.x,0.0,velocity_.z},
			{velocity_.x,velocity_.y,0.0},
			{0.0,0.0,velocity_.z},
			{0.0,velocity_.y,0.0},
			{velocity_.x,0.0,0.0}
		};
		for (auto& v : possible_move_vectors) {
			updateCollisionPos(old_pos + v);
			bool could_move = true;
			for (auto& other_model : getCollisionModels()) {
				if (isCollision(other_model)) {
					could_move = false;
					break;
				}
			}
			if (could_move) {
				setPos(old_pos + v);
				break;
			}
		}
	}
	else if (getCollsionModel()->getType() == CollisionModel::Type::SPHERE) {
		Vector3 old_origin = getCollsionModel()->getOrigin();
		bool keep_origin = false;
		auto tri_loop_test = [&](Model* other_model) {
			const Stage& o = dynamic_cast<const Stage&> (*other_model);
			for (auto& tri : o.getTriangles()) {
				if (tri.isCollision(old_origin, velocity_)) {
					keep_origin = true;
					break;
				}
			}
			};

		for (auto& other_model : getCollisionModels()) {
			updateCollisionPos(old_origin + velocity_);
			if (other_model->getCollsionModel()->getType() == CollisionModel::SPHERE && isCollision(other_model)) {
				Vector3 t = other_model->getCollsionModel()->getOrigin() - old_origin;
				double s = 1 / t.squareDist();
				velocity_ -= t * (velocity_.dot(t)) * (1 / t.squareDist());
			}
			else if (other_model->getCollsionModel()->getType() == CollisionModel::TRIANGLE) { // ç¢°æ’æ£€æµ‹çš„éƒ¨åˆ†å¯ä»¥ç»§ç»­ä¼˜åŒ–ï¼Œè¿™éƒ¨åˆ†å†™çš„ä¸å¤ªä¼˜é›…
				const Stage& o = dynamic_cast<const Stage&> (*other_model);
				for (auto& tri : o.getTriangles()) {
					if (tri.isCollision(old_origin, velocity_)) {
						Vector3 n = tri.getNorm();
						double lambda = n.dot(velocity_) / n.dot(n);
						velocity_ -= n * lambda;
					}
				}
				// (*) ä¸‰è§’å½¢æ˜¯æ•°ç»„ï¼Œå› æ­¤è¦å¾ªç¯ï¼Œ
				// ä¸ºäº†é¿å…é—´éš™å¤„çš„ç©¿é€é—®é¢˜ï¼Œä½¿ç”¨ä¸¤æ¬¡å¾ªç¯ï¼Œç¬¬ä¸€æ¬¡å¾ªç¯å¦‚æœæ²¡æœ‰å‘ç”Ÿç¢°æ’ï¼Œåˆ™ç›´æ¥ä½¿ç”¨å°±å¯ä»¥
				// å¦‚æœå‘ç”Ÿäº†ç¢°æ’ï¼Œä½¿ç”¨æ ¡æ­£åçš„å‘é‡è¿›è¡Œç¬¬äºŒæ¬¡å¾ªç¯ï¼Œå› æ­¤æœ¬æ¬¡æ˜¯ä¸ä¼šå’Œä¹‹å‰å·²ç»ç¢°æ’ä¿®å¤è¿‡çš„å†ç¢°æ’ï¼Œå¦‚æœè¿˜æ˜¯å‘ç”Ÿäº†ç¢°æ’åˆ™ä¸å¯ä»¥ä½¿ç”¨è¿™æ¬¡çš„ç§»åŠ¨ï¼Œå¦åˆ™ä¼šç©¿é€ä¹‹å‰çš„ç‰©ä½“
				tri_loop_test(other_model);
			}
		}
		// åŒæ³¨é‡Šï¼ˆ*ï¼‰ï¼Œå¯¹å¤šä¸ªç‰©ä½“å¾ªç¯ä¸¤æ¬¡
		for (auto& other_model : getCollisionModels()) {
			if (other_model->getCollsionModel()->getType() == CollisionModel::TRIANGLE) {
				tri_loop_test(other_model);
			}
		}
		if (keep_origin) {
			updateCollisionPos(old_origin); // ä¹‹å‰çš„bugæ˜¯ç”±ä¸æ²¡æœ‰åŒæ­¥æ›´æ–°è¿™ä¸ªå‘é‡å¯¼è‡´
		}
		else {
			updateCollisionPos(old_origin + velocity_);
			setPos(old_pos + velocity_);
		}
	}
}
    
}

```

##  å¦‚ä½•è¿è¡Œ

### ç³»ç»Ÿè¦æ±‚

- Windows 10
- Visual Studio 2022

### æ„å»ºæ­¥éª¤

1. å…‹éš†ä»“åº“ï¼š

   ```bash
   git clone https://github.com/nekoqqq/MiniGame
   ```

2. æ‰“å¼€è§£å†³æ–¹æ¡ˆæ–‡ä»¶`MiniGame.sln`

3. è®¾ç½®`3D`ä¸ºå¯åŠ¨é¡¹ç›®

4. æ„å»ºå¹¶è°ƒè¯•ï¼ˆF5ï¼‰æˆ–è€…è¿è¡Œ(Ctrl+F5)

### æ§åˆ¶è¯´æ˜

- **WASD**ï¼šè§’è‰²ç§»åŠ¨
- **ç©ºæ ¼**ï¼šè·³è·ƒ+é”å®šæ•Œäºº
- Jï¼šå‘å°„è·Ÿè¸ªå¯¼å¼¹
- **U**ï¼šè§†è§’å·¦ç§»
- **I**ï¼šè§†è§’å³ç§»
- **C**ï¼šé”å®šæ•Œäºº
- **Q**ï¼šé€€å‡ºæ¸¸æˆ

## æœªæ¥è®¡åˆ’

- å®ç°è‡ªå·±çš„Shader
- ç”»é¢ä¼˜åŒ–ï¼Œåœºæ™¯ä¸­å¼•å…¥æ›´å¤šçš„å…ƒç´ 
- æ·»åŠ æ›´åŠ é«˜çº§çš„æ¸¸æˆç…§æ˜ç³»ç»Ÿï¼Œå¦‚*Blinn-Phong*æ¨¡å‹
- ä¼˜åŒ–çš„å¯¼å¼¹è¿½è¸ªç³»ç»Ÿï¼Œç°åœ¨å¯¼å¼¹ç³»ç»Ÿæœ‰ä¸€å®šå‡ ç‡ä¼šåŸåœ°çš„ç›˜æ—‹
- åœºæ™¯ä¼˜åŒ–ï¼Œå¢åŠ å¤æ‚æ¤è¢«å’Œå¤©ç©º
- ç¢°æ’ç³»ç»Ÿä¼˜åŒ–ï¼Œé‡‡ç”¨BVHç±»ä¼¼çš„æ–¹æ³•å®ç°é«˜æ•ˆåœ°ç¢°æ’æ£€æµ‹
- å®Œå–„æ¸¸æˆUI
- èµ„æºè¯»å–ä¼˜åŒ–

## è®¸å¯è¯

æœ¬é¡¹ç›®é‡‡ç”¨MITè®¸å¯è¯ - è¯¦æƒ…è¯·å‚é˜…[LICENSE](https://license/)æ–‡ä»¶ã€‚
